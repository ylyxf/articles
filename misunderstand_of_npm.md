## npm与maven的一点差异

nmp的install命令，会根据当前目录/项目下的package.json文件去自动组织和下载依赖库，这点和maven非常相似。但是遇到多级依赖时，npm和maven的处理却大不一样。

举个例子：项目直接依赖A和B，其中A依赖C，B也依赖C，`npm install`最后行的目录结构是：
```
Project
    |--A
    |  |--C
    |
    |--B
       |--C
```
这样的结果会让人觉得npm很傻，为什么会把模块C下载两次？优先计算一下依赖关系不就可以了吗？如果是maven，只会下载一次模块C。

但是，如果A依赖的是C的1.0版本，B依赖的是C的2.0版本，问题就不那么简单了，如果是npm，则会生成如下的目录结构：
```
Project
    |--A
    |  |--C@1.0
    |
    |--B
       |--C@2.0
```
如果是maven呢？它只会下载某一版本的C模块，至于同一个模块， 使用哪一个版本，有两条原则来指导：其一，模块所在的依赖层次越浅，优先级越高；其二 ，依赖层次相同（如本例），谁先声明则谁的优先级最高。

为什么同样是依赖管理，maven和npm差别那么大呢？我们细细琢磨一下，似乎npm的更加周全一些，maven似乎有些死板，如果当真C的1.0与2.0不兼容，那么必然A包或者B包会有一个出问题。

其实，这个差别的原因，是由于nodejs和java对于模块化的不同设计造成的，更深入地说，是JavaScript的命名空间特性的特殊性保障了npm的周全。

我们知道，不管在代码层面上如何模块化，最终大家都是运行在同一个进程当中的。按照java的命名空间的要去，包名+类名是在全进程中唯一定位某一类型的，com.package.modulec.C在运行的时候只能存在一个，哪怕classpath中同时放置了c@1.0.jar和c@2.0.jar，最终的ClassLoader也只会加载其中一个com.package.modulec.C类。

而nodejs则不同，它的module机制，是将模块的功能定义在了一个独立的子命名空间中，相互直接是有作用域隔离的。在运行时，A模块引用的C@1.0与B模块引用的C@2.0，分别处在两个独立的作用域中，相互之间不受影响。这个最基本的特性，可以让npm无顾虑地忠实于各依赖模块原来的依赖的关系，让各依赖模块比maven中的依赖关系更加稳定。当然，其带来的缺点就是，可能有多级依赖是相同的，却在不同层次的node_modules目录下，被下载和安装了多次，npm3也在尝试用扁平化依赖和重复依赖计算等手段解决这些问题。


